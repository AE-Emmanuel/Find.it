"""
ASI Client Module for FIND.it
Handles all communication with fetch.ai ASI API
"""

import os
import requests
import uuid
import time
import re
from typing import Dict, List, Optional
from dotenv import load_dotenv

load_dotenv()

class ASIClient:
    """Client for interacting with ASI API"""
    
    def __init__(self):
        self.api_key = os.getenv('ASI_API_KEY')
        if not self.api_key:
            raise ValueError("ASI_API_KEY not found in environment variables")
        
        # session id can be provided via env var or will be autogenerated per client
        self.session_id = os.getenv('ASI_SESSION_ID') or str(uuid.uuid4())

        self.base_url = "https://api.asi1.ai/v1/chat/completions"
        self.headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json",
            "x-session-id": self.session_id,
            "Accept": "application/json"
        }
        
        # Response cache for faster repeated queries
        self._response_cache = {}
        
    def _make_request(self, prompt: str, system_prompt: str = None, 
                      temperature: float = 0.7, max_tokens: int = 500, retry_count: int = 2) -> str:
        """
        Make a request to ASI API with caching and retry logic
        
        Args:
            prompt: User message/prompt
            system_prompt: System instructions
            temperature: Creativity level (0-1)
            max_tokens: Maximum response length
            retry_count: Number of retry attempts
            
        Returns:
            ASI response text
        """
        # Check cache for identical requests
        cache_key = f"{prompt[:50]}_{max_tokens}_{temperature}"
        if cache_key in self._response_cache:
            print("📦 Using cached response")
            return self._response_cache[cache_key]
        
        messages = []
        
        if system_prompt:
            messages.append({"role": "system", "content": system_prompt})
        
        messages.append({"role": "user", "content": prompt})
        
        payload = {
            "model": "asi1-fast-agentic",  
            "messages": messages,
            "temperature": temperature,
            "max_tokens": max_tokens
        }
        
        try:
            response = requests.post(
                self.base_url,
                headers=self.headers,
                json=payload,
                timeout=30 if max_tokens > 200 else 15  
            )
            
            # Debug: print response details if error
            if response.status_code != 200:
                print(f"Status Code: {response.status_code}")
                print(f"Response: {response.text}")
            
            response.raise_for_status()
            
            result = response.json()
            
            # Handle thinking blocks in ASI response
            content = result['choices'][0]['message']['content'].strip()
            
            # Remove <think> blocks if present
            if '<think>' in content:
                content = content.split('</think>')[-1].strip()
            
            # Cache successful response
            self._response_cache[cache_key] = content
            
            return content
            
        except requests.exceptions.Timeout:
            if retry_count > 0:
                wait_time = (3 - retry_count) * 2  # 2s, 4s exponential backoff
                print(f"⏱️ Timeout, waiting {wait_time}s before retry ({retry_count} attempts left)...")
                time.sleep(wait_time)
                return self._make_request(prompt, system_prompt, temperature, max_tokens, retry_count - 1)
            print("❌ Request timed out after all retries")
            return "TIMEOUT_ERROR"
            
        except requests.exceptions.RequestException as e:
            print(f"❌ ASI API Error: {str(e)}")
            return f"API_ERROR: {str(e)}"
    
    def _extract_object_entities(self, text: str) -> List[str]:
        """Extract object names from command"""
        # Common objects blind users look for
        objects_db = [
            # Personal items
            'keys', 'key', 'phone', 'mobile', 'cellphone', 'smartphone', 'wallet', 'purse', 
            'glasses', 'spectacles', 'sunglasses', 'watch', 'ring', 'earring', 'necklace', 'bracelet',
            # Electronics
            'remote', 'charger', 'cable', 'laptop', 'computer', 'tablet', 'ipad',
            'headphones', 'earbuds', 'airpods', 'mouse', 'keyboard',
            # Daily items
            'cup', 'mug', 'glass', 'bottle', 'plate', 'bowl', 'fork', 'knife', 'spoon',
            'pen', 'pencil', 'paper', 'book', 'magazine', 'newspaper',
            'bag', 'backpack', 'purse', 'shoe', 'shoes', 'socks', 'sock', 'hat', 'cap',
            'umbrella', 'jacket', 'coat', 'shirt', 'pants', 'trousers',
            # Medical
            'medicine', 'pills', 'pill', 'inhaler', 'cane', 'medication', 'drugs',
            # Misc
            'door', 'window', 'chair', 'table', 'desk', 'bed', 'couch', 'sofa', 'lamp', 'light',
            'tv', 'television', 'clock', 'mirror', 'brush', 'comb', 'towel'
        ]
        
        found_objects = []
        
        # Check for each object in the command
        for obj in objects_db:
            if obj in text:
                found_objects.append(obj)
        
        # If no specific object found, try to extract from patterns
        if not found_objects:
            # Pattern: "where is my X" or "find my X" or "looking for X"
            patterns = [
                r'my\s+(\w+)',
                r'the\s+(\w+)', 
                r'find\s+(\w+)',
                r'looking\s+for\s+(\w+)',
                r'where.*\s+(\w+)',
                r'locate\s+(\w+)',
                r'search\s+for\s+(\w+)'
            ]
            
            for pattern in patterns:
                match = re.search(pattern, text)
                if match:
                    potential_obj = match.group(1).rstrip('?.,!').lower()
                    # Avoid common filler words
                    if potential_obj not in ['is', 'are', 'the', 'my', 'a', 'an', 'it', 'this', 'that']:
                        found_objects.append(potential_obj)
                        break
        
        # Return unique objects
        return list(set(found_objects)) if found_objects else ['item']
    
    def _extract_text_entities(self, text: str) -> List[str]:
        """Extract what kind of text user wants to read"""
        text_types = ['sign', 'label', 'document', 'paper', 'letter', 'card', 'note', 
                     'menu', 'receipt', 'bill', 'message', 'email', 'text']
        
        found = [t for t in text_types if t in text]
        return found if found else ['text']
    
    def parse_intent(self, voice_command: str) -> Dict:
        """
        Local rule-based intent parser (100% reliable, no ASI calls)
        
        Args:
            voice_command: Raw voice input from user
            
        Returns:
            Dictionary with intent, action, entities
        """
        cmd_lower = voice_command.lower().strip()
        
        print(f"🔍 Parsing: '{voice_command}'")
        
        # Pattern matching with priority order
        
        # 1. EMERGENCY (highest priority)
        emergency_keywords = ['emergency', 'help', 'danger', 'urgent', 'sos', '911', 'alert', 'accident', 'hurt', 'injured']
        if any(kw in cmd_lower for kw in emergency_keywords):
            print("✅ Intent: EMERGENCY")
            return {
                "intent": "emergency",
                "action": "alert",
                "entities": [],
                "confidence": 0.99
            }
        
        # 2. READ TEXT
        read_keywords = ['read', 'text', 'sign', 'label', 'letter', 'word', 'writing', 'written', 'says', 'what does', 'whats on']
        if any(kw in cmd_lower for kw in read_keywords):
            entities = self._extract_text_entities(cmd_lower)
            print(f"✅ Intent: READ_TEXT (entities: {entities})")
            return {
                "intent": "read_text",
                "action": "ocr",
                "entities": entities,
                "confidence": 0.95
            }
        
        # 3. FIND OBJECT (most common)
        find_keywords = ['where', 'find', 'locate', 'looking for', 'search', 'lost', 
                        'cant find', "can't find", 'see my', 'my', 'the']
        if any(kw in cmd_lower for kw in find_keywords):
            entities = self._extract_object_entities(cmd_lower)
            print(f"✅ Intent: FIND_OBJECT (entities: {entities})")
            return {
                "intent": "find_object",
                "action": "locate",
                "entities": entities,
                "confidence": 0.90
            }
        
        # 4. NAVIGATE/DESCRIBE SCENE
        describe_keywords = ['around', 'see', 'front', 'describe', 'what', 'scene', 
                            'environment', 'nearby', 'here', 'whats', "what's", 'show']
        if any(kw in cmd_lower for kw in describe_keywords):
            print("✅ Intent: DESCRIBE_SCENE")
            return {
                "intent": "describe_scene",
                "action": "describe",
                "entities": [],
                "confidence": 0.85
            }
        
        # 5. DEFAULT - Assume describe scene for ambiguous commands
        print("✅ Intent: DESCRIBE_SCENE (default)")
        return {
            "intent": "describe_scene",
            "action": "describe",
            "entities": [],
            "confidence": 0.70
        }
    
    def describe_scene(self, detected_objects: List[str], 
                       object_locations: Optional[List[Dict]] = None,
                       user_query: Optional[str] = None) -> str:
        """
        Generate natural language scene description
        
        Args:
            detected_objects: List of detected object names
            object_locations: Optional list of {object, position, confidence}
            user_query: Optional specific question from user
            
        Returns:
            Natural language description for TTS
        """
        # Shortened prompt for faster response
        system_prompt = """Scene describer for blind users. 2 sentences max. Use: "on your left", "in front", "to your right"."""

        # Build concise prompt
        prompt_parts = []
        
        if user_query:
            prompt_parts.append(f'Q: "{user_query}"')
        
        prompt_parts.append(f"Objects: {', '.join(detected_objects[:5])}")  # Limit to 5 objects
        
        if object_locations:
            locations_text = "; ".join([
                f"{obj['object']} {obj['position']}"
                for obj in object_locations[:3]  # Only top 3
            ])
            prompt_parts.append(f"Positions: {locations_text}")
        
        prompt_parts.append("Describe:")
        prompt = "\n".join(prompt_parts)
        
        response = self._make_request(prompt, system_prompt, temperature=0.7, max_tokens=150)
        
        # Fallback if ASI fails
        if "TIMEOUT_ERROR" in response or "API_ERROR" in response:
            if object_locations:
                return f"I see {len(detected_objects)} objects. {object_locations[0]['object']} is {object_locations[0]['position']}."
            return f"I detect {len(detected_objects)} objects including {', '.join(detected_objects[:3])}."
        
        return response
    
    def find_object_guidance(self, target_object: str, 
                            detected_objects: List[Dict]) -> str:
        """
        Generate guidance to help user find a specific object
        
        Args:
            target_object: Object user is looking for
            detected_objects: List of {object, position, distance, confidence}
            
        Returns:
            Guidance instructions
        """
        # Check if target object is detected
        found_objects = [obj for obj in detected_objects 
                        if target_object.lower() in obj['object'].lower()]
        
        if found_objects:
            best_match = found_objects[0]
            
            # Shortened prompt
            system_prompt = "Help blind person find object. 1-2 clear sentences. Use spatial terms."
            
            prompt = f"Looking for: {target_object}. Found {best_match['object']} {best_match['position']}. Guide:"
            
            response = self._make_request(prompt, system_prompt, temperature=0.6, max_tokens=80)
            
            # Fallback
            if "TIMEOUT_ERROR" in response or "API_ERROR" in response:
                return f"Your {best_match['object']} is {best_match['position']}. Look there."
            
            return response
        else:
            # Object not found - simple response
            if detected_objects:
                nearby = ', '.join([obj['object'] for obj in detected_objects[:3]])
                return f"I don't see {target_object}. I can see {nearby}. Try looking around or capture another image."
            else:
                return f"I don't see {target_object} in the current view. Try moving the camera around and capture again."
    
    def clean_ocr_text(self, raw_ocr_text: str) -> str:
        """
        Clean and structure OCR output for better readability
        
        Args:
            raw_ocr_text: Raw text from OCR engine
            
        Returns:
            Cleaned, readable text
        """
        if not raw_ocr_text or raw_ocr_text.strip() == "":
            return "No text detected in the image."
        
        # Simple cleaning without ASI if text is already clean
        if len(raw_ocr_text) < 100 and raw_ocr_text.replace('\n', ' ').isprintable():
            cleaned = raw_ocr_text.replace('\n', ' ').strip()
            return cleaned if cleaned else "No text detected in the image."
        
        system_prompt = "Clean OCR text for text-to-speech. Fix errors, keep meaning."
        prompt = f"Clean: {raw_ocr_text[:500]}"  # Limit input length
        
        response = self._make_request(prompt, system_prompt, temperature=0.3, max_tokens=200)
        
        # Fallback: basic cleaning
        if "TIMEOUT_ERROR" in response or "API_ERROR" in response:
            # Basic cleanup
            cleaned = raw_ocr_text.replace('\n\n', '. ').replace('\n', ' ')
            cleaned = ' '.join(cleaned.split())  # Remove extra spaces
            return cleaned if cleaned else "Text unclear"
        
        return response


# Test function
def test_asi_client():
    """Test ASI client functionality"""
    try:
        client = ASIClient()
        
        print("="*60)
        print("🧪 Testing Local Intent Parser")
        print("="*60)
        
        test_cases = [
            "Where are my keys?",
            "Find my phone",
            "I can't find my glasses",
            "Read the sign in front of me",
            "What does this say?",
            "What's around me?",
            "Describe the scene",
            "Help! Emergency!",
            "I need urgent help",
            "Show me what's in front",
            "Looking for my wallet",
            "My remote is missing"
        ]
        
        for cmd in test_cases:
            result = client.parse_intent(cmd)
            print(f"\n'{cmd}'")
            print(f"  → Intent: {result['intent']}")
            print(f"  → Action: {result['action']}")
            print(f"  → Entities: {result['entities']}")
            print(f"  → Confidence: {result['confidence']:.0%}")
        
        # Test 2: Scene description
        print("\n" + "="*60)
        print("Test: Scene Description")
        print("="*60)
        objects = ["cup", "laptop", "book"]
        locations = [
            {"object": "cup", "position": "on your left", "confidence": 0.95},
            {"object": "laptop", "position": "in front of you", "confidence": 0.88}
        ]
        description = client.describe_scene(objects, locations, "What's on the table?")
        print(f"Description: {description}\n")
        
        # Test 3: Find object
        print("\n" + "="*60)
        print("Test: Find Object Guidance")
        print("="*60)
        detected = [
            {"object": "keys", "position": "on the counter to your right", 
             "distance": "2 feet", "confidence": 0.92}
        ]
        guidance = client.find_object_guidance("keys", detected)
        print(f"Guidance: {guidance}\n")
        
        # Test 4: Object not found
        print("\n" + "="*60)
        print("Test: Object Not Found")
        print("="*60)
        detected2 = [
            {"object": "cup", "position": "on your left", "confidence": 0.88},
            {"object": "laptop", "position": "in front", "confidence": 0.92}
        ]
        guidance2 = client.find_object_guidance("phone", detected2)
        print(f"Guidance: {guidance2}\n")
        
        print("\n" + "="*60)
        print("✅ All tests completed!")
        print("="*60)
        return True
        
    except Exception as e:
        print(f"❌ Test failed: {e}")
        import traceback
        traceback.print_exc()
        return False


if __name__ == "__main__":
    test_asi_client()